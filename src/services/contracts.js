
import { supabase } from '../lib/supabase'

export const contractService = {
    async fetchContracts() {
        if (!supabase) return []
        const { data, error } = await supabase
            .from('contracts')
            .select('*')
            .order('created_at', { ascending: false })

        if (error) {
            console.error('Error fetching contracts:', error)
            return []
        }
        return data ? data.map(this.mapFromDb) : []
    },

    async createContract(contract) {
        if (!supabase) return null

        // Calculate main status (dominant or 'MIXED')
        const mainStatus = this.deriveMainStatus(contract.statusDetails)

        const dbPayload = {
            // id is auto-generated by DB
            client_name: contract.clientName,
            type: contract.type,
            status: mainStatus,
            status_details: contract.statusDetails, // New JSON column
            cups_count: contract.cupsCount,
            contract_ids: contract.contractIds, // Array of strings
            notes: contract.notes,
            salesperson: contract.salesperson,
            date: contract.date,
            created_at: new Date().toISOString()
        }

        const { data, error } = await supabase
            .from('contracts')
            .insert([dbPayload])
            .select()

        if (error) {
            console.error('Error creating contract:', error)
            throw error
        }

        if (data && data.length > 0) {
            return this.mapFromDb(data[0])
        }
        return null
    },

    async deleteContract(id) {
        if (!supabase) return { success: false, error: 'No connection' }
        const { error } = await supabase
            .from('contracts')
            .delete()
            .eq('id', id)

        if (error) {
            console.error('Error deleting:', error)
            return { success: false, error: error.message }
        }
        return { success: true }
    },

    async updateStatus(id, statusInput) {
        if (!supabase) return false

        let updatePayload = {}

        if (typeof statusInput === 'string') {
            // Simple update: Clear details, set status
            updatePayload = {
                status: statusInput,
                status_details: null // Reset details if switching back to simple status
            }
        } else {
            // granular update
            const mainStatus = this.deriveMainStatus(statusInput)
            updatePayload = {
                status: mainStatus,
                status_details: statusInput
            }
        }

        const { error } = await supabase
            .from('contracts')
            .update(updatePayload)
            .eq('id', id)

        if (error) {
            console.error('Error updating status:', error)
            return false
        }
        return true
    },

    async updateContract(id, updates) {
        if (!supabase) return false

        // Map app keys to db keys if needed
        const dbPayload = {}
        if (updates.notes !== undefined) dbPayload.notes = updates.notes
        // Add others as needed in future

        const { error } = await supabase
            .from('contracts')
            .update(dbPayload)
            .eq('id', id)

        if (error) {
            console.error('Error updating contract:', error)
            return false
        }
        return true
    },

    deriveMainStatus(details) {
        if (!details) return 'PENDIENTE'
        // If all equal one status, use that. Else 'MIXED' or simplified logic.
        const keys = Object.keys(details).filter(k => details[k] > 0)
        if (keys.length === 1) return keys[0]
        return 'VARIOS' // Special status for mixed
    },

    // Helper to convert DB snake_case to App camelCase
    mapFromDb(dbRecord) {
        return {
            id: dbRecord.id,
            clientName: dbRecord.client_name,
            type: dbRecord.type,
            status: dbRecord.status,
            statusDetails: dbRecord.status_details, // Load JSON
            cupsCount: dbRecord.cups_count,
            contractIds: dbRecord.contract_ids || [], // Default to empty array
            dni: dbRecord.dni,
            phone: dbRecord.phone,
            address: dbRecord.address,
            iban: dbRecord.iban,
            representativeName: dbRecord.representative_name,
            representativeDni: dbRecord.representative_dni,
            notes: dbRecord.notes,
            salesperson: dbRecord.salesperson,
            date: dbRecord.date
        }
    }
}
